using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using redb.Core.Data;
using redb.Core.Models.Contracts;
using redb.Core.Models.Entities;
using redb.Core.Providers;

namespace redb.Postgres.Materialization
{
    /// <summary>
    /// –ú–∞—Ç–µ—Ä–∏–∞–ª–∏–∑–∞—Ç–æ—Ä Props –∏–∑ RedbValue –∑–∞–ø–∏—Å–µ–π
    /// –ü—Ä—è–º–æ–π –ø–µ—Ä–µ–≤–æ–¥ SQL —Ñ—É–Ω–∫—Ü–∏–π get_object_json –∏ build_hierarchical_properties_optimized –≤ C#
    /// –†–∞–±–æ—Ç–∞–µ—Ç —Å values –∏–∑ –ø–∞–º—è—Ç–∏ –ë–ï–ó –æ–±—Ä–∞—â–µ–Ω–∏–π –∫ –ë–î
    /// </summary>
    public class PropsMaterializer
    {
        private readonly ISchemeSyncProvider _schemeSync;
        private readonly Dictionary<long, IRedbScheme> _schemeCache;
        private readonly Dictionary<long, (string? DbType, string? TypeSemantic)>? _typeInfoCache;
        private readonly Dictionary<long, IRedbListItem>? _preloadedListItems;  // ‚ö° –ù–û–í–û–ï: –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–µ ListItem –¥–ª—è BULK –º–∞—Ç–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏–∏
        
        // === –°–¢–ê–¢–ò–ß–ï–°–ö–ò–ô –ü–†–û–í–ê–ô–î–ï–† –°–ü–ò–°–ö–û–í (–¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ IRedbListItem) ===
        private static IListProvider? _globalListProvider;
        
        /// <summary>
        /// –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≥–ª–æ–±–∞–ª—å–Ω—ã–π –ø—Ä–æ–≤–∞–π–¥–µ—Ä —Å–ø–∏—Å–∫–æ–≤ –¥–ª—è –≤—Å–µ—Ö PropsMaterializer
        /// </summary>
        public static void SetGlobalListProvider(IListProvider provider)
        {
            _globalListProvider = provider ?? throw new ArgumentNullException(nameof(provider));
        }
        
        /// <summary>
        /// –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ª–∏ –≥–ª–æ–±–∞–ª—å–Ω—ã–π –ø—Ä–æ–≤–∞–π–¥–µ—Ä —Å–ø–∏—Å–∫–æ–≤
        /// </summary>
        public static bool IsListProviderAvailable => _globalListProvider != null;

        public PropsMaterializer(ISchemeSyncProvider schemeSync)
        {
            _schemeSync = schemeSync ?? throw new ArgumentNullException(nameof(schemeSync));
            _schemeCache = new Dictionary<long, IRedbScheme>();
            _typeInfoCache = null;
            _preloadedListItems = null;
        }
        
        public PropsMaterializer(ISchemeSyncProvider schemeSync, Dictionary<long, IRedbScheme> preloadedSchemes)
        {
            _schemeSync = schemeSync ?? throw new ArgumentNullException(nameof(schemeSync));
            _schemeCache = preloadedSchemes ?? new Dictionary<long, IRedbScheme>();
            _typeInfoCache = null;
            _preloadedListItems = null;
        }
        
        public PropsMaterializer(ISchemeSyncProvider schemeSync, Dictionary<long, IRedbScheme> preloadedSchemes, Dictionary<long, (string? DbType, string? TypeSemantic)> typeInfoCache)
        {
            _schemeSync = schemeSync ?? throw new ArgumentNullException(nameof(schemeSync));
            _schemeCache = preloadedSchemes ?? new Dictionary<long, IRedbScheme>();
            _typeInfoCache = typeInfoCache;
            _preloadedListItems = null;
        }
        
        /// <summary>
        /// ‚ö° –ù–û–í–´–ô –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä —Å –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–º–∏ ListItem –¥–ª—è BULK –º–∞—Ç–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏–∏
        /// </summary>
        public PropsMaterializer(
            ISchemeSyncProvider schemeSync, 
            Dictionary<long, IRedbScheme> preloadedSchemes, 
            Dictionary<long, (string? DbType, string? TypeSemantic)> typeInfoCache,
            Dictionary<long, IRedbListItem> preloadedListItems)
        {
            _schemeSync = schemeSync ?? throw new ArgumentNullException(nameof(schemeSync));
            _schemeCache = preloadedSchemes ?? new Dictionary<long, IRedbScheme>();
            _typeInfoCache = typeInfoCache;
            _preloadedListItems = preloadedListItems;  // ‚ö° –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–µ ListItem
        }

        /// <summary>
        /// –ê–Ω–∞–ª–æ–≥ get_object_json - —Ä–∞–±–æ—Ç–∞–µ—Ç —Å values –∏–∑ –ü–ê–ú–Ø–¢–ò!
        /// SQL: —Å—Ç—Ä–æ–∫–∏ 243-331 –≤ redb_json_objects.sql
        /// </summary>
        public TProps GetObjectProps<TProps>(
            long objectId,
            List<RedbValue> allValuesForObject,
            long schemeId,
            int maxDepth,
            ConcurrentBag<long> nestedObjectIdsCollector) where TProps : class, new()
        {
            if (maxDepth <= 0)
            {
                return new TProps();
            }

            // SQL —Å—Ç—Ä–æ–∫–∞ 298-313: –ì—Ä—É–ø–ø–∏—Ä—É–µ–º values –ø–æ structure_id (–∫–∞–∫ jsonb_object_agg)
            var valuesByStructure = allValuesForObject
                .GroupBy(v => v.IdStructure)
                .ToDictionary(g => g.Key, g => g.ToList());

            // SQL —Å—Ç—Ä–æ–∫–∞ 316-324: –í—ã–∑—ã–≤–∞–µ–º build_hierarchical_properties_optimized
            return BuildHierarchicalPropertiesOptimized<TProps>(
                objectId,
                null, // parent_structure_id = NULL –¥–ª—è –∫–æ—Ä–Ω—è
                schemeId,
                valuesByStructure,
                allValuesForObject,
                maxDepth,
                null, // array_index = NULL
                null, // parent_value_id = NULL
                nestedObjectIdsCollector);
        }

        /// <summary>
        /// –ê–Ω–∞–ª–æ–≥ build_hierarchical_properties_optimized
        /// SQL: —Å—Ç—Ä–æ–∫–∏ 8-240 –≤ redb_json_objects.sql
        /// </summary>
        private TProps BuildHierarchicalPropertiesOptimized<TProps>(
            long objectId,
            long? parentStructureId,
            long schemeId,
            Dictionary<long, List<RedbValue>> valuesByStructure,
            List<RedbValue> allValues,
            int maxDepth,
            string? arrayIndex,
            long? parentValueId,
            ConcurrentBag<long> nestedObjectIdsCollector) where TProps : class, new()
        {
            // SQL —Å—Ç—Ä–æ–∫–∞ 28-31: –ó–∞—â–∏—Ç–∞ –æ—Ç —Ä–µ–∫—É—Ä—Å–∏–∏
            if (maxDepth <= 0)
            {
                return new TProps();
            }

            var result = new TProps();

            // SQL —Å—Ç—Ä–æ–∫–∞ 34-47: –ü–æ–ª—É—á–∞–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Å—Ö–µ–º—ã
            // –í–ê–ñ–ù–û: –∏—Å–ø–æ–ª—å–∑—É–µ–º preloaded cache, –ù–ï –æ–±—Ä–∞—â–∞–µ–º—Å—è –∫ _schemeSync –≤ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–º –∫–æ–¥–µ!
            if (!_schemeCache.TryGetValue(schemeId, out var scheme))
            {
                // Fallback: –µ—Å–ª–∏ —Å—Ö–µ–º—ã –Ω–µ—Ç –≤ –∫–µ—à–µ (–Ω–µ –¥–æ–ª–∂–Ω–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç—å –≤ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–º –∫–æ–¥–µ)
                return result;
            }
            
            if (scheme == null)
            {
                return result;
            }

            var structures = scheme.Structures
                .Where(s => s.IdParent == parentStructureId)
                .OrderBy(s => s.Order ?? 0)
                .ThenBy(s => s.Id)
                .ToList();

            // SQL —Å—Ç—Ä–æ–∫–∞ 48: FOR LOOP –ø–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º
            foreach (var structure in structures)
            {
                
                // SQL —Å—Ç—Ä–æ–∫–∞ 50-73: –ü–æ–ª—É—á–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
                // üî• FIX: –ü–µ—Ä–µ–¥–∞—ë–º parentValueId –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞ –ø–æ–ª–µ–π –≤–Ω—É—Ç—Ä–∏ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
                List<RedbValue> currentValues = GetValuesForStructure(
                    structure.Id, arrayIndex, parentValueId, valuesByStructure, allValues);

                // –ü–æ–ª—É—á–∞–µ–º typeInfo –∑–∞—Ä–∞–Ω–µ–µ –¥–ª—è –≤—Å–µ—Ö —Å–ª—É—á–∞–µ–≤ (–¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –≤ SetPropertyValue)
                var typeInfo = GetTypeInfo(structure, currentValues);

                // SQL —Å—Ç—Ä–æ–∫–∞ 102-230: CASE –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ–ª—è
                object? fieldValue = null;

                if (structure.CollectionType == Core.Utils.RedbTypeIds.Array)
                {
                    // SQL —Å—Ç—Ä–æ–∫–∞ 104-179: –ú–∞—Å—Å–∏–≤—ã
                    fieldValue = BuildArrayField(
                        objectId, structure, schemeId, valuesByStructure,
                        allValues, maxDepth, parentValueId, nestedObjectIdsCollector, typeof(TProps));
                }
                else if (structure.CollectionType == Core.Utils.RedbTypeIds.Dictionary)
                {
                    // Dictionary<K,V> fields
                    fieldValue = BuildDictionaryField(
                        objectId, structure, schemeId, valuesByStructure,
                        allValues, maxDepth, parentValueId, nestedObjectIdsCollector, typeof(TProps));
                }
                else
                {
                    if (typeInfo.TypeSemantic == "_RObject")
                    {
                        // SQL —Å—Ç—Ä–æ–∫–∞ 183-188: Object —Å—Å—ã–ª–∫–∞ –Ω–∞ –¥—Ä—É–≥–æ–π –æ–±—ä–µ–∫—Ç
                        // üî• FIX: –ß–∏—Ç–∞–µ–º –∏–∑ Object (—Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ–µ –ø–æ–ª–µ –¥–ª—è FK –Ω–∞ _objects), –Ω–µ –∏–∑ Long!
                        var nestedId = currentValues?.FirstOrDefault()?.Object;
                        if (nestedId.HasValue)
                        {
                            nestedObjectIdsCollector.Add(nestedId.Value); // thread-safe!
                            // –°–æ–∑–¥–∞–µ–º placeholder —Å id –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–π –ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∏
                            var propertyType = typeof(TProps).GetProperty(structure.Name)?.PropertyType;
                            if (propertyType != null && propertyType.IsGenericType && 
                                propertyType.GetGenericTypeDefinition() == typeof(RedbObject<>))
                            {
                                // –°–æ–∑–¥–∞–µ–º RedbObject<TNestedProps> —Å —Ç–æ–ª—å–∫–æ id
                                var placeholder = Activator.CreateInstance(propertyType);
                                propertyType.GetProperty("id")?.SetValue(placeholder, nestedId.Value);
                                fieldValue = placeholder;
                            }
                        }
                    }
                    else if (typeInfo.TypeSemantic == "Object")
                    {
                        // SQL —Å—Ç—Ä–æ–∫–∞ 191-205: Class –ø–æ–ª–µ —Å –∏–µ—Ä–∞—Ä—Ö–∏—á–µ—Å–∫–∏–º–∏ –¥–æ—á–µ—Ä–Ω–∏–º–∏ –ø–æ–ª—è–º–∏
                        var currentValue = currentValues?.FirstOrDefault();
                        if (currentValue?.Guid.HasValue == true)
                        {
                            // Class –ø–æ–ª–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –ù–ï NULL - —Å—Ç—Ä–æ–∏–º –æ–±—ä–µ–∫—Ç
                            var propertyType = typeof(TProps).GetProperty(structure.Name)?.PropertyType;
                            if (propertyType != null)
                            {
                                var buildMethod = typeof(PropsMaterializer)
                                    .GetMethod(nameof(BuildHierarchicalPropertiesOptimized), 
                                        BindingFlags.NonPublic | BindingFlags.Instance)?
                                    .MakeGenericMethod(propertyType);

                                // –í–ê–ñ–ù–û: –ø–µ—Ä–µ–¥–∞—ë–º currentValue.Id –∫–∞–∫ parentValueId –¥–ª—è –¥–æ—á–µ—Ä–Ω–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤!
                                fieldValue = buildMethod?.Invoke(this, new object?[]
                                {
                                    objectId, structure.Id, schemeId, valuesByStructure,
                                    allValues, maxDepth - 1, arrayIndex, currentValue.Id,
                                    nestedObjectIdsCollector
                                });
                            }
                        }
                    }
                    else
                    {
                        // SQL —Å—Ç—Ä–æ–∫–∞ 208-229: –ü—Ä–∏–º–∏—Ç–∏–≤–Ω—ã–µ —Ç–∏–ø—ã
                        fieldValue = ExtractSimpleValue(typeInfo.DbType, typeInfo.TypeSemantic, currentValues?.FirstOrDefault());
                    }
                }

                // SQL —Å—Ç—Ä–æ–∫–∞ 232-234: –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª–µ –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ NULL
                if (fieldValue != null)
                {
                    SetPropertyValue(result, structure.Name, fieldValue, typeInfo.DbType, typeInfo.TypeSemantic);
                }
            }

            return result;
        }

        /// <summary>
        /// –û–±—Ä–∞–±–æ—Ç–∫–∞ –º–∞—Å—Å–∏–≤–æ–≤ (–ø—Ä–æ—Å—Ç—ã—Ö —Ç–∏–ø–æ–≤, Class, RedbObjectRow)
        /// SQL: —Å—Ç—Ä–æ–∫–∏ 104-179 –≤ redb_json_objects.sql
        /// </summary>
        private object? BuildArrayField(
            long objectId,
            IRedbStructure structure,
            long schemeId,
            Dictionary<long, List<RedbValue>> valuesByStructure,
            List<RedbValue> allValues,
            int maxDepth,
            long? parentValueId,
            ConcurrentBag<long> nestedObjectIdsCollector,
            Type propsType)
        {
            // –ü–æ–ª—É—á–∞–µ–º values –¥–ª—è —ç—Ç–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —á—Ç–æ–±—ã –∏–∑–≤–ª–µ—á—å type info
            valuesByStructure.TryGetValue(structure.Id, out var structureValues);
            var typeInfo = GetTypeInfo(structure, structureValues ?? new List<RedbValue>());

            // SQL —Å—Ç—Ä–æ–∫–∞ 78-99: –ü–æ–ª—É—á–∞–µ–º ID –±–∞–∑–æ–≤–æ–π –∑–∞–ø–∏—Å–∏ –º–∞—Å—Å–∏–≤–∞
            long? baseArrayValueId = GetBaseArrayValueId(objectId, structure.Id, parentValueId, allValues);

            if (typeInfo.TypeSemantic == "Object")
            {
                // SQL —Å—Ç—Ä–æ–∫–∞ 107-136: –ú–∞—Å—Å–∏–≤ Class –ø–æ–ª–µ–π - —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ
                var arrayElements = allValues
                    .Where(v => v.IdStructure == structure.Id &&
                               !string.IsNullOrEmpty(v.ArrayIndex) &&
                               (!baseArrayValueId.HasValue || v.ArrayParentId == baseArrayValueId))
                    .OrderBy(v => int.TryParse(v.ArrayIndex, out var idx) ? idx : 0)
                    .ToList();

                if (!arrayElements.Any())
                {
                    // üî• FIX: –ü—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤ = [] (–Ω–µ NULL!)
                    var emptyElementType = GetArrayElementType(propsType, structure.Name);
                    var emptyListType = typeof(List<>).MakeGenericType(emptyElementType);
                    return Activator.CreateInstance(emptyListType);
                }

                var elementType = GetArrayElementType(propsType, structure.Name);
                var listType = typeof(List<>).MakeGenericType(elementType);
                var list = (System.Collections.IList)Activator.CreateInstance(listType)!;

                foreach (var element in arrayElements)
                {
                    var buildMethod = typeof(PropsMaterializer)
                        .GetMethod(nameof(BuildHierarchicalPropertiesOptimized),
                            BindingFlags.NonPublic | BindingFlags.Instance)?
                        .MakeGenericMethod(elementType);

                    var elementObj = buildMethod?.Invoke(this, new object?[]
                    {
                        objectId, structure.Id, schemeId, valuesByStructure,
                        allValues, maxDepth - 1, element.ArrayIndex, element.Id,
                        nestedObjectIdsCollector
                    });

                    if (elementObj != null)
                    {
                        list.Add(elementObj);
                    }
                }

                return list;
            }
            else
            {
                // SQL —Å—Ç—Ä–æ–∫–∞ 138-178: –ú–∞—Å—Å–∏–≤—ã –ø—Ä–æ—Å—Ç—ã—Ö —Ç–∏–ø–æ–≤
                var arrayValues = allValues
                    .Where(v => v.IdStructure == structure.Id &&
                               !string.IsNullOrEmpty(v.ArrayIndex) &&
                               (!baseArrayValueId.HasValue || v.ArrayParentId == baseArrayValueId))
                    .OrderBy(v => int.TryParse(v.ArrayIndex, out var idx) ? idx : 0)
                    .ToList();

                if (!arrayValues.Any())
                {
                    // üî• FIX: –ü—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤ = [] (–Ω–µ NULL!)
                    var emptyElementType = typeInfo.TypeSemantic == "_RObject" 
                        ? GetArrayElementType(propsType, structure.Name)
                        : GetSimpleTypeForDbType(typeInfo.DbType);
                    var emptyListType = typeof(List<>).MakeGenericType(emptyElementType);
                    return Activator.CreateInstance(emptyListType);
                }

                if (typeInfo.TypeSemantic == "_RObject")
                {
                    // SQL —Å—Ç—Ä–æ–∫–∞ 145-146: –ú–∞—Å—Å–∏–≤ _RObject —Å—Å—ã–ª–æ–∫
                    // üî• FIX: –ß–∏—Ç–∞–µ–º –∏–∑ Object (—Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ–µ –ø–æ–ª–µ –¥–ª—è FK –Ω–∞ _objects), –Ω–µ –∏–∑ Long!
                    var ids = arrayValues.Select(v => v.Object).Where(id => id.HasValue).Select(id => id!.Value).ToList();
                   //Console.WriteLine($"[BuildArrayField] üîó –ú–∞—Å—Å–∏–≤ RedbObjectRow: structure={structure.Name}, ids=[{string.Join(",", ids)}]");
                    foreach (var id in ids)
                    {
                        nestedObjectIdsCollector.Add(id);
                    }
                    
                    // –°–æ–∑–¥–∞–µ–º placeholder list –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–π –ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∏
                    var elementType = GetArrayElementType(propsType, structure.Name);
                   //Console.WriteLine($"[BuildArrayField]   elementType={elementType?.Name}, isRedbObject={elementType?.IsGenericType == true && elementType.GetGenericTypeDefinition() == typeof(RedbObject<>)}");
                    if (elementType.IsGenericType && elementType.GetGenericTypeDefinition() == typeof(RedbObject<>))
                    {
                        var listType = typeof(List<>).MakeGenericType(elementType);
                        var list = (System.Collections.IList)Activator.CreateInstance(listType)!;
                        
                        foreach (var id in ids)
                        {
                            var placeholder = Activator.CreateInstance(elementType);
                            elementType.GetProperty("id")?.SetValue(placeholder, id);
                            list.Add(placeholder);
                        }
                        
                       //Console.WriteLine($"[BuildArrayField]   ‚úÖ –°–æ–∑–¥–∞–Ω placeholder list: count={list.Count}");
                        return list;
                    }
                    
                   //Console.WriteLine($"[BuildArrayField]   ‚ùå elementType –Ω–µ RedbObject, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º null");
                    return null;
                }
                else
                {
                    // SQL —Å—Ç—Ä–æ–∫–∞ 147-162: –ü—Ä–æ—Å—Ç—ã–µ —Ç–∏–ø—ã
                    var actualDbType = typeInfo.DbType;
                    
                    // ‚ö†Ô∏è –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ï—Å–ª–∏ TypeSemantic="_RListItem", –Ω–æ DbType="Long" (—Å—Ç–∞—Ä–∞—è —Å—Ö–µ–º–∞), –∏—Å–ø—Ä–∞–≤–ª—è–µ–º
                    if (actualDbType == "Long" && typeInfo.TypeSemantic == "_RListItem")
                    {
                       //System.Console.WriteLine($"[BuildArrayField] ‚ö†Ô∏è –û–ë–ù–ê–†–£–ñ–ï–ù–ê –ü–†–û–ë–õ–ï–ú–ê: TypeSemantic=_RListItem, –Ω–æ DbType=Long (—Å—Ç–∞—Ä–∞—è —Å—Ö–µ–º–∞). –ò—Å–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ ListItem.");
                        actualDbType = "ListItem";
                    }
                    
                    // ‚ö° –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —ç–ª–µ–º–µ–Ω—Ç–∞ –º–∞—Å—Å–∏–≤–∞
                    Type elementType;
                    
                    // –û–°–û–ë–´–ô –°–õ–£–ß–ê–ô: –î–ª—è ListItem –í–°–ï–ì–î–ê –∏—Å–ø–æ–ª—å–∑—É–µ–º IRedbListItem (–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å)
                    // –≠—Ç–æ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
                    if (actualDbType == "ListItem")
                    {
                        elementType = typeof(IRedbListItem);
                    }
                    else
                    {
                        // –î–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Ç–∏–ø–æ–≤: –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–∏–ø –∏–∑ DbType (long, double, string –∏ —Ç.–¥.)
                        elementType = GetSimpleTypeForDbType(actualDbType);
                       //System.Console.WriteLine($"[BuildArrayField] –ü—Ä–æ—Å—Ç–æ–π –º–∞—Å—Å–∏–≤: DbType={actualDbType}, elementType={elementType.Name}");
                    }
                    
                    var listType = typeof(List<>).MakeGenericType(elementType);
                    var list = (System.Collections.IList)Activator.CreateInstance(listType)!;
                    
                   //System.Console.WriteLine($"[BuildArrayField] –°–æ–∑–¥–∞–Ω list type={listType.Name}");

                    // ‚≠ê –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø –¥–ª—è ListItem: –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                    if (actualDbType == "ListItem")
                    {
                       //System.Console.WriteLine($"[BuildArrayField] –û–±—Ä–∞–±–æ—Ç–∫–∞ ListItem –º–∞—Å—Å–∏–≤–∞");
                        
                        var listItemIds = arrayValues
                            .Where(v => v.ListItem.HasValue)
                            .Select(v => v.ListItem!.Value)
                            .ToList();
                        
                       //System.Console.WriteLine($"[BuildArrayField] –ù–∞–π–¥–µ–Ω–æ {listItemIds.Count} ListItem IDs: {string.Join(", ", listItemIds)}");
                        
                        if (listItemIds.Any())
                        {
                            // ‚ö° –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 1: –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–µ ListItem (BULK –º–∞—Ç–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è)
                            if (_preloadedListItems != null)
                            {
                               //System.Console.WriteLine($"[BuildArrayField] ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–µ ListItem (count={_preloadedListItems.Count})");
                                
                                // –ó–∞–ø–æ–ª–Ω—è–µ–º —Å–ø–∏—Å–æ–∫ –∏–∑ –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö (–ë–ï–ó –∑–∞–ø—Ä–æ—Å–æ–≤ –∫ –ë–î!)
                                foreach (var val in arrayValues.OrderBy(v => v.ArrayIndex))
                                {
                                    if (val.ListItem.HasValue && _preloadedListItems.TryGetValue(val.ListItem.Value, out var listItem))
                                    {
                                       //System.Console.WriteLine($"[BuildArrayField] –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–π ListItem: Index={val.ArrayIndex}, ID={val.ListItem.Value}, Value={listItem.Value}");
                                        list.Add(listItem);
                                    }
                                    else
                                    {
                                       //System.Console.WriteLine($"[BuildArrayField] ‚ö†Ô∏è ListItem ID={val.ListItem.Value} –ù–ï –Ω–∞–π–¥–µ–Ω –≤ –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö!");
                                    }
                                }
                                
                               //System.Console.WriteLine($"[BuildArrayField] ‚úÖ –ú–∞—Å—Å–∏–≤ ListItem –∑–∞–ø–æ–ª–Ω–µ–Ω –∏–∑ –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö, count={list.Count}");
                            }
                            // ‚ö†Ô∏è Fallback: –∑–∞–≥—Ä—É–∂–∞–µ–º –∏–∑ _globalListProvider (–µ—Å–ª–∏ –Ω–µ—Ç –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö)
                            else if (_globalListProvider != null)
                            {
                               //System.Console.WriteLine($"[BuildArrayField] ‚ö†Ô∏è Fallback: –∑–∞–≥—Ä—É–∑–∫–∞ ListItem —á–µ—Ä–µ–∑ _globalListProvider (–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ)");
                                
                                // –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è DbContext threading issues
                                var listItemsDict = new Dictionary<long, IRedbListItem?>();
                                foreach (var id in listItemIds.Distinct())
                                {
                                   //System.Console.WriteLine($"[BuildArrayField] –ó–∞–≥—Ä—É–∑–∫–∞ ListItem ID={id}");
                                    var item = Task.Run(async () => await _globalListProvider.GetListItemAsync(id)).GetAwaiter().GetResult();
                                    if (item != null)
                                    {
                                        listItemsDict[id] = item;
                                       //System.Console.WriteLine($"[BuildArrayField] ‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω ListItem ID={id}, Value={item.Value}");
                                    }
                                }
                                
                                // –ó–∞–ø–æ–ª–Ω—è–µ–º —Å–ø–∏—Å–æ–∫ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
                                foreach (var val in arrayValues.OrderBy(v => v.ArrayIndex))
                                {
                                    if (val.ListItem.HasValue && listItemsDict.TryGetValue(val.ListItem.Value, out var listItem))
                                    {
                                        list.Add(listItem);
                                    }
                                }
                                
                               //System.Console.WriteLine($"[BuildArrayField] ‚úÖ –ú–∞—Å—Å–∏–≤ ListItem –∑–∞–ø–æ–ª–Ω–µ–Ω, count={list.Count}");
                            }
                        }
                    }
                    else
                    {
                        // –û–±—ã—á–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è –¥—Ä—É–≥–∏—Ö —Ç–∏–ø–æ–≤
                        foreach (var val in arrayValues)
                        {
                            var simpleValue = ExtractSimpleValue(typeInfo.DbType, typeInfo.TypeSemantic, val);
                            if (simpleValue != null)
                            {
                                list.Add(simpleValue);
                            }
                        }
                    }

                    return list;
                }
            }
        }

        /// <summary>
        /// Build Dictionary field from RedbValue records.
        /// Dictionary elements stored with serialized keys in _array_index.
        /// </summary>
        private object? BuildDictionaryField(
            long objectId,
            IRedbStructure structure,
            long schemeId,
            Dictionary<long, List<RedbValue>> valuesByStructure,
            List<RedbValue> allValues,
            int maxDepth,
            long? parentValueId,
            ConcurrentBag<long> nestedObjectIdsCollector,
            Type propsType)
        {
            // Get values for this structure to extract type info
            valuesByStructure.TryGetValue(structure.Id, out var structureValues);
            var typeInfo = GetTypeInfo(structure, structureValues ?? new List<RedbValue>());
            
            // Get base record for Dictionary (same logic as Array)
            long? baseDictValueId = GetBaseArrayValueId(objectId, structure.Id, parentValueId, allValues);
            
            // Get property type to determine Dictionary<TKey, TValue> types
            var property = propsType.GetProperty(structure.Name);
            if (property == null || property.GetIndexParameters().Length > 0)
                return null;
            
            var propertyType = property.PropertyType;
            if (!propertyType.IsGenericType) return null;
            
            var genericDef = propertyType.GetGenericTypeDefinition();
            if (genericDef != typeof(Dictionary<,>) && genericDef != typeof(IDictionary<,>)) 
                return null;
            
            var genericArgs = propertyType.GetGenericArguments();
            if (genericArgs.Length != 2) return null;
            
            var keyType = genericArgs[0];
            var valueType = genericArgs[1];
            
            // Create concrete Dictionary<TKey, TValue> instance
            var dictType = typeof(Dictionary<,>).MakeGenericType(keyType, valueType);
            var dict = Activator.CreateInstance(dictType);
            if (dict == null) return null;
            
            // Get Add method for the concrete Dictionary type
            var addMethod = dictType.GetMethod("Add", new[] { keyType, valueType });
            if (addMethod == null) return null;
            
            // Get Dictionary elements (records with ArrayIndex = serialized key)
            var dictElements = allValues
                .Where(v => v.IdStructure == structure.Id &&
                           !string.IsNullOrEmpty(v.ArrayIndex) &&
                           (!baseDictValueId.HasValue || v.ArrayParentId == baseDictValueId))
                .ToList();
            
            if (!dictElements.Any())
            {
                return dict; // Return empty Dictionary
            }
            
            foreach (var element in dictElements)
            {
                // Deserialize key from ArrayIndex
                var key = Core.Utils.RedbKeySerializer.DeserializeObject(element.ArrayIndex!, keyType);
                if (key == null) continue;
                
                object? value = null;
                
                // Check if value is RedbObject<T> - either by TypeSemantic or by C# type
                var isRedbObjectValue = typeInfo.TypeSemantic == "_RObject" || 
                    (valueType.IsGenericType && valueType.GetGenericTypeDefinition() == typeof(RedbObject<>));
                
                if (isRedbObjectValue)
                {
                    // Dictionary<K, RedbObject<T>> - collect nested object IDs for later loading
                    if (element.Object.HasValue)
                    {
                        nestedObjectIdsCollector.Add(element.Object.Value);
                        
                        // Create placeholder RedbObject with only id set
                        var placeholder = Activator.CreateInstance(valueType);
                        valueType.GetProperty("id")?.SetValue(placeholder, element.Object.Value);
                        value = placeholder;
                    }
                }
                else if (typeInfo.TypeSemantic == "Object")
                {
                    // Dictionary<K, ClassType> - build class from child values
                    var buildMethod = typeof(PropsMaterializer)
                        .GetMethod(nameof(BuildHierarchicalPropertiesOptimized),
                            BindingFlags.NonPublic | BindingFlags.Instance)?
                        .MakeGenericMethod(valueType);

                    value = buildMethod?.Invoke(this, new object?[]
                    {
                        objectId, structure.Id, schemeId, valuesByStructure,
                        allValues, maxDepth - 1, element.ArrayIndex, element.Id,
                        nestedObjectIdsCollector
                    });
                }
                else
                {
                    // Dictionary<K, PrimitiveType> - extract simple value
                    value = ExtractSimpleValue(typeInfo.DbType, typeInfo.TypeSemantic, element);
                    
                    // Convert value to target type if needed (e.g., long to decimal)
                    if (value != null && value.GetType() != valueType && !valueType.IsAssignableFrom(value.GetType()))
                    {
                        try
                        {
                            value = Convert.ChangeType(value, valueType, CultureInfo.InvariantCulture);
                        }
                        catch
                        {
                            // If conversion fails, skip this element
                            continue;
                        }
                    }
                }
                
                if (value != null)
                {
                    // Invoke Add method with proper types
                    addMethod.Invoke(dict, new[] { key, value });
                }
            }
            
            return dict;
        }

        /// <summary>
        /// –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –ø—Ä–æ—Å—Ç—ã—Ö —Ç–∏–ø–æ–≤ –∏–∑ RedbValue
        /// SQL: —Å—Ç—Ä–æ–∫–∏ 208-229 –≤ redb_json_objects.sql
        /// </summary>
        private object? ExtractSimpleValue(string? dbType, string? typeSemantic, RedbValue? value)
        {
            if (value == null) return null;

            //System.Console.WriteLine($"[PropsMaterializer.ExtractSimpleValue] üîç –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è: dbType={dbType}, IdStructure={value.IdStructure}, ListItem={value.ListItem}, Long={value.Long}");

            // ‚úÖ –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ï—Å–ª–∏ dbType=Long, –Ω–æ value.ListItem.HasValue, —Ç–æ —ç—Ç–æ ListItem, —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π –≤ —Å—Ç–∞—Ä—É—é —Å—Ö–µ–º—É
            if (dbType == "Long" && value.ListItem.HasValue)
            {
                //System.Console.WriteLine($"[PropsMaterializer.ExtractSimpleValue] ‚ö†Ô∏è –û–ë–ù–ê–†–£–ñ–ï–ù ListItem –≤ –ø–æ–ª–µ —Å dbType=Long (—Å—Ç–∞—Ä–∞—è —Å—Ö–µ–º–∞). –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–∞–∫ ListItem.");
                return ExtractListItemValue(value);
            }

            return dbType switch
            {
                "String" => value.String,
                "Long" => value.Long,
                "Boolean" => value.Boolean,
                // DateTime: –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º DateTimeOffset ‚Üí DateTime (UTC)
                "DateTime" => value.DateTimeOffset.HasValue 
                    ? Core.Utils.DateTimeConverter.DenormalizeFromStorage(value.DateTimeOffset.Value)
                    : (DateTime?)null,
                "DateTimeOffset" => value.DateTimeOffset,
                "Double" => value.Double,
                "Numeric" => value.Numeric,
                "Guid" => value.Guid,
                "ByteArray" => value.ByteArray,
                "ListItem" => ExtractListItemValue(value),
                "Object" => value.Object,
                _ => null
            };
        }

        /// <summary>
        /// –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è ListItem —Å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º
        /// </summary>
        private IRedbListItem? ExtractListItemValue(RedbValue? value)
        {
            if (value == null || !value.ListItem.HasValue)
            {
                //System.Console.WriteLine($"[PropsMaterializer.ExtractListItemValue] ‚ÑπÔ∏è value.ListItem –Ω–µ –∏–º–µ–µ—Ç –∑–Ω–∞—á–µ–Ω–∏—è (NULL)");
                return null;
            }
            
            //System.Console.WriteLine($"[PropsMaterializer.ExtractListItemValue] üîç ListItem –æ–±–Ω–∞—Ä—É–∂–µ–Ω: Id={value.ListItem.Value}, _globalListProvider={(_globalListProvider != null ? "available" : "NULL")}");
            
            if (_globalListProvider == null)
            {
                //System.Console.WriteLine($"[PropsMaterializer.ExtractListItemValue] ‚ö†Ô∏è _globalListProvider NULL, –≤–æ–∑–≤—Ä–∞—â–∞—é null");
                return null;
            }
            
            //System.Console.WriteLine($"[PropsMaterializer.ExtractListItemValue] üöÄ –í—ã–∑–æ–≤ GetListItemAsync —á–µ—Ä–µ–∑ Task.Run...");
            
            // ‚ö†Ô∏è –ö–†–ò–¢–ò–ß–ù–û: Task.Run –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è deadlock –ø—Ä–∏ –≤—ã–∑–æ–≤–µ EF Core async –∏–∑ sync –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
            var listItem = Task.Run(async () => 
            {
                //System.Console.WriteLine($"[PropsMaterializer.ExtractListItemValue/Task.Run] üìû –í–Ω—É—Ç—Ä–∏ Task.Run, –≤—ã–∑—ã–≤–∞–µ–º GetListItemAsync({value.ListItem.Value})");
                var result = await _globalListProvider.GetListItemAsync(value.ListItem.Value);
                //System.Console.WriteLine($"[PropsMaterializer.ExtractListItemValue/Task.Run] ‚úÖ GetListItemAsync –∑–∞–≤–µ—Ä—à–µ–Ω, result={result?.Id}");
                return result;
            }).GetAwaiter().GetResult();
            
            //System.Console.WriteLine($"[PropsMaterializer.ExtractListItemValue] ‚úÖ ListItem –∑–∞–≥—Ä—É–∂–µ–Ω: Id={listItem?.Id}, Value={listItem?.Value}, IdObject={listItem?.IdObject}");
            return listItem;
        }

        /// <summary>
        /// –ü–æ–ª—É—á–µ–Ω–∏–µ values –¥–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Å —É—á–µ—Ç–æ–º array_index –∏ parent_value_id
        /// SQL: —Å—Ç—Ä–æ–∫–∏ 50-73 –≤ redb_json_objects.sql
        /// </summary>
        private List<RedbValue> GetValuesForStructure(
            long structureId,
            string? arrayIndex,
            long? parentValueId,
            Dictionary<long, List<RedbValue>> valuesByStructure,
            List<RedbValue> allValues)
        {
            if (parentValueId.HasValue)
            {
                // üî• FIX: –î–ª—è –ø–æ–ª–µ–π –í–ù–£–¢–†–ò —ç–ª–µ–º–µ–Ω—Ç–∞ –º–∞—Å—Å–∏–≤–∞ - –∏—â–µ–º –ø–æ ArrayParentId
                // –≠—Ç–æ –∫–∞—Å–∞–µ—Ç—Å—è –ø–æ–ª–µ–π –∫–∞–∫ Details[j].Key, Details[j].Value
                return allValues
                    .Where(v => v.IdStructure == structureId && v.ArrayParentId == parentValueId.Value)
                    .ToList();
            }
            else if (string.IsNullOrEmpty(arrayIndex))
            {
                // –î–ª—è –æ–±—ã—á–Ω—ã—Ö –ø–æ–ª–µ–π –∏–ª–∏ –∫–æ—Ä–Ω–µ–≤—ã—Ö –ø–æ–ª–µ–π –º–∞—Å—Å–∏–≤–∞
                if (valuesByStructure.TryGetValue(structureId, out var values))
                {
                    return values;
                }
                return new List<RedbValue>();
            }
            else
            {
                // –î–ª—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞ - –∏—â–µ–º —Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º array_index
                return allValues
                    .Where(v => v.IdStructure == structureId && v.ArrayIndex == arrayIndex)
                    .ToList();
            }
        }

        /// <summary>
        /// –ü–æ–ª—É—á–µ–Ω–∏–µ ID –±–∞–∑–æ–≤–æ–π –∑–∞–ø–∏—Å–∏ –º–∞—Å—Å–∏–≤–∞
        /// SQL: —Å—Ç—Ä–æ–∫–∏ 78-99 –≤ redb_json_objects.sql
        /// </summary>
        private long? GetBaseArrayValueId(long objectId, long structureId, long? parentValueId, List<RedbValue> allValues)
        {
            if (parentValueId == null)
            {
                // –ö–æ—Ä–Ω–µ–≤–æ–π –º–∞—Å—Å–∏–≤: _array_parent_id –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å NULL
                return allValues
                    .FirstOrDefault(v => v.IdObject == objectId &&
                                        v.IdStructure == structureId &&
                                        v.ArrayIndex == null &&
                                        v.ArrayParentId == null)?.Id;
            }
            else
            {
                // –í–ª–æ–∂–µ–Ω–Ω—ã–π –º–∞—Å—Å–∏–≤: _array_parent_id –¥–æ–ª–∂–µ–Ω —Å–æ–≤–ø–∞–¥–∞—Ç—å —Å parentValueId
                return allValues
                    .FirstOrDefault(v => v.IdObject == objectId &&
                                        v.IdStructure == structureId &&
                                        v.ArrayIndex == null &&
                                        v.ArrayParentId == parentValueId)?.Id;
            }
        }

        /// <summary>
        /// –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–Ω–∞—á–µ–Ω–∏—è —Å–≤–æ–π—Å—Ç–≤–∞ —á–µ—Ä–µ–∑ Reflection
        /// –ö–†–ò–¢–ò–ß–ù–û: –ª—é–±–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–µ—Ä—ã–≤–∞–µ—Ç –ø—Ä–æ—Ü–µ—Å—Å!
        /// </summary>
        private void SetPropertyValue<TProps>(TProps target, string propertyName, object value, string? dbType = null, string? typeSemantic = null)
        {
            var property = typeof(TProps).GetProperty(propertyName, BindingFlags.Public | BindingFlags.Instance);
            if (property != null && property.CanWrite)
            {
                // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Ç–∏–ø–æ–≤ –µ—Å–ª–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ
                var convertedValue = ConvertValue(value, property.PropertyType, dbType, typeSemantic);
                property.SetValue(target, convertedValue);
                // –û–®–ò–ë–ö–ò –ù–ï –õ–û–í–ò–ú - –ø—É—Å—Ç—å –ª–µ—Ç–∏—Ç –Ω–∞–≤–µ—Ä—Ö –∏ –ø—Ä–µ—Ä—ã–≤–∞–µ—Ç –≤—Å—ë!
            }
        }

        /// <summary>
        /// –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –∫ —Ü–µ–ª–µ–≤–æ–º—É —Ç–∏–ø—É
        /// –ò—Å–ø–æ–ª—å–∑—É–µ—Ç TypeSemantic –∏–∑ –ë–î –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –∫–æ–Ω–≤–µ—Ä—Å–∏–∏ (Enum, TimeSpan –∏ —Ç.–¥.)
        /// </summary>
        private object? ConvertValue(object value, Type targetType, string? dbType = null, string? typeSemantic = null)
        {
            if (value == null) return null;

            var valueType = value.GetType();
            if (targetType.IsAssignableFrom(valueType))
            {
                return value;
            }

            // ‚úÖ –û–±—Ä–∞–±–æ—Ç–∫–∞ RedbObject<T> references (–∫–æ–≥–¥–∞ value —ç—Ç–æ long ID, –∞ target —ç—Ç–æ RedbObject<T>)
            if (value is long nestedId && targetType.IsGenericType && 
                targetType.GetGenericTypeDefinition() == typeof(RedbObject<>))
            {
                // –°–æ–∑–¥–∞–µ–º placeholder —Å ID –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–π –∑–∞–≥—Ä—É–∑–∫–∏
                var placeholder = Activator.CreateInstance(targetType);
                targetType.GetProperty("id")?.SetValue(placeholder, nestedId);
                return placeholder;
            }

            // ‚úÖ –ü–†–ò–û–†–ò–¢–ï–¢: –∏—Å–ø–æ–ª—å–∑—É–µ–º TypeSemantic –∏–∑ –ë–î (_types.type) –¥–ª—è —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Ç–∏–ø–æ–≤
            if (!string.IsNullOrEmpty(typeSemantic))
            {
                switch (typeSemantic)
                {
                    case "Enum":
                        // Enum –º–æ–∂–µ—Ç —Ö—Ä–∞–Ω–∏—Ç—å—Å—è –∫–∞–∫ String ("High") –∏–ª–∏ Long (2)
                        if (targetType.IsEnum)
                        {
                            if (dbType == "String" && value is string enumString)
                            {
                                return Enum.Parse(targetType, enumString);
                            }
                            else if ((dbType == "Long" || dbType == "bigint") && value is long enumLong)
                            {
                                return Enum.ToObject(targetType, enumLong);
                            }
                            else if (value is int enumInt)
                            {
                                return Enum.ToObject(targetType, enumInt);
                            }
                        }
                        break;
                    
                    case "TimeSpan":
                        if (value is string timeSpanString)
                        {
                            return TimeSpan.Parse(timeSpanString);
                        }
                        break;
                    
                    case "TimeOnly":
                        if (value is string timeOnlyString)
                        {
                            return TimeOnly.Parse(timeOnlyString);
                        }
                        else if (value is DateTime dateTime)
                        {
                            return TimeOnly.FromDateTime(dateTime);
                        }
                        else if (value is DateTimeOffset dateTimeOffset)
                        {
                            return TimeOnly.FromDateTime(dateTimeOffset.DateTime);
                        }
                        break;
                    
                    case "DateOnly":
                        if (value is string dateOnlyString)
                        {
                            return DateOnly.Parse(dateOnlyString);
                        }
                        else if (value is DateTime dateTime2)
                        {
                            return DateOnly.FromDateTime(dateTime2);
                        }
                        else if (value is DateTimeOffset dateTime3)
                        {
                            return DateOnly.FromDateTime(dateTime3.UtcDateTime);
                        }
                        break;
                }
            }

            // ‚úÖ –û–±—Ä–∞–±–æ—Ç–∫–∞ char (String ‚Üí char[0])
            if (targetType == typeof(char) && value is string charString && charString.Length > 0)
            {
                return charString[0];
            }

            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–ª–ª–µ–∫—Ü–∏–π (List, Array)
            if (typeof(System.Collections.IEnumerable).IsAssignableFrom(valueType) && 
                valueType != typeof(string))
            {
                // –ï—Å–ª–∏ value —ç—Ç–æ –∫–æ–ª–ª–µ–∫—Ü–∏—è, –∞ target —ç—Ç–æ –º–∞—Å—Å–∏–≤
                if (targetType.IsArray)
                {
                    var elementType = targetType.GetElementType();
                    if (elementType != null && value is System.Collections.IList list)
                    {
                        var array = Array.CreateInstance(elementType, list.Count);
                        for (int i = 0; i < list.Count; i++)
                        {
                            // –í–ê–ñ–ù–û: –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä long ‚Üí double)
                            var element = list[i];
                            if (element != null && !elementType.IsAssignableFrom(element.GetType()))
                            {
                                try
                                {
                                    element = ConvertValue(element, elementType, dbType, typeSemantic);
                                }
                                catch
                                {
                                    // –ï—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å —Å–∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç
                                    element = elementType.IsValueType ? Activator.CreateInstance(elementType) : null;
                                }
                            }
                            array.SetValue(element, i);
                        }
                        return array;
                    }
                }
                
                // –ï—Å–ª–∏ value —ç—Ç–æ List<T>, –∞ target —Ç–æ–∂–µ List<T>, –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø—ã
                if (targetType.IsGenericType && targetType.GetGenericTypeDefinition() == typeof(List<>))
                {
                    var targetElementType = targetType.GetGenericArguments()[0];
                    if (value is System.Collections.IList list)
                    {
                        // üî• FIX: –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Ç–∏–ø–∞ –°–ü–ò–°–ö–ê, –Ω–µ —Ç–æ–ª—å–∫–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
                        // List<IRedbListItem> –Ω–µ–ª—å–∑—è –ø—Ä–∏—Å–≤–æ–∏—Ç—å –∫ List<RedbListItem> –¥–∞–∂–µ –µ—Å–ª–∏ —ç–ª–µ–º–µ–Ω—Ç—ã —Å–æ–≤–º–µ—Å—Ç–∏–º—ã!
                        bool listTypeCompatible = targetType.IsAssignableFrom(valueType);
                        
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–∞ –ª–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤
                        bool needsElementConversion = false;
                        if (list.Count > 0 && list[0] != null)
                        {
                            needsElementConversion = !targetElementType.IsAssignableFrom(list[0].GetType());
                        }
                        
                        // –ù—É–∂–Ω–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –µ—Å–ª–∏: —Ç–∏–ø—ã —Å–ø–∏—Å–∫–æ–≤ –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º—ã –ò–õ–ò —ç–ª–µ–º–µ–Ω—Ç—ã –Ω—É–∂–Ω–æ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å
                        if (!listTypeCompatible || needsElementConversion)
                        {
                            var listType = typeof(List<>).MakeGenericType(targetElementType);
                            var newList = (System.Collections.IList)Activator.CreateInstance(listType)!;
                            
                            foreach (var item in list)
                            {
                                try
                                {
                                    var converted = item != null && !targetElementType.IsAssignableFrom(item.GetType())
                                        ? ConvertValue(item, targetElementType, dbType, typeSemantic)
                                        : item;
                                    newList.Add(converted);
                                }
                                catch
                                {
                                    // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å
                                }
                            }
                            return newList;
                        }
                    }
                }
                
                // –ï—Å–ª–∏ —Ç–∏–ø—ã —Å–æ–≤–º–µ—Å—Ç–∏–º—ã, –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º
                return value;
            }

            // –û–±—Ä–∞–±–æ—Ç–∫–∞ Nullable types
            var underlyingType = Nullable.GetUnderlyingType(targetType);
            if (underlyingType != null)
            {
                // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ underlying —Ç–∏–ø —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º typeSemantic
                return ConvertValue(value, underlyingType, dbType, typeSemantic);
            }

            // ‚úÖ FALLBACK –¥–ª—è Enum (–µ—Å–ª–∏ TypeSemantic –Ω–µ –±—ã–ª –ø–µ—Ä–µ–¥–∞–Ω –∏–∑ –ë–î)
            if (targetType.IsEnum)
            {
                if (value is string enumString)
                {
                    return Enum.Parse(targetType, enumString);
                }
                else if (value is long enumLong)
                {
                    return Enum.ToObject(targetType, enumLong);
                }
                else if (value is int enumInt)
                {
                    return Enum.ToObject(targetType, enumInt);
                }
            }

            // ‚úÖ –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ DateTimeOffset ‚Üí DateTime
            // DateTimeOffset –Ω–µ —Ä–µ–∞–ª–∏–∑—É–µ—Ç IConvertible, –ø–æ—ç—Ç–æ–º—É Convert.ChangeType –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç
            if (value is DateTimeOffset dateTimeOffsetValue && targetType == typeof(DateTime))
            {
                // ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –∫–æ–Ω–≤–µ—Ä—Ç–µ—Ä: DateTimeOffset ‚Üí DateTime (UTC)
                return Core.Utils.DateTimeConverter.DenormalizeFromStorage(dateTimeOffsetValue);
            }

            // Fallback: —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è —á–µ—Ä–µ–∑ Convert.ChangeType
            return Convert.ChangeType(value, targetType);
        }

        /// <summary>
        /// –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç–∏–ø–µ –∏–∑ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
        /// –°–Ω–∞—á–∞–ª–∞ –∏—â–µ–º –≤ preloaded –∫–µ—à–µ —Ç–∏–ø–æ–≤, –ø–æ—Ç–æ–º fallback –Ω–∞ RedbValue.StructureNavigation
        /// </summary>
        private (string? DbType, string? TypeSemantic) GetTypeInfo(IRedbStructure structure, List<RedbValue> currentValues)
        {
            // Use preloaded type dictionary from scheme (no Include needed!)
            if (_typeInfoCache != null && _typeInfoCache.TryGetValue(structure.Id, out var typeInfo))
            {
                return typeInfo;
            }
            
            // If unable to get - return null
            // IMPORTANT: Do NOT access _schemeSync in parallel code!
            return (null, null);
        }

        /// <summary>
        /// –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–∏–ø–∞ —ç–ª–µ–º–µ–Ω—Ç–∞ –º–∞—Å—Å–∏–≤–∞ —á–µ—Ä–µ–∑ —Ä–µ—Ñ–ª–µ–∫—Å–∏—é
        /// </summary>
        private Type GetArrayElementType(Type propsType, string propertyName)
        {
            // –ù–∞—Ö–æ–¥–∏–º —Å–≤–æ–π—Å—Ç–≤–æ –ø–æ –∏–º–µ–Ω–∏
            var property = propsType.GetProperty(propertyName, BindingFlags.Public | BindingFlags.Instance);
            if (property == null)
            {
                return typeof(object); // Fallback –µ—Å–ª–∏ —Å–≤–æ–π—Å—Ç–≤–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
            }

            var propertyType = property.PropertyType;

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∞—Å—Å–∏–≤: Contact[] –∏–ª–∏ RedbObject<T>[]
            if (propertyType.IsArray)
            {
                return propertyType.GetElementType() ?? typeof(object);
            }

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º List<T>: List<Contact> –∏–ª–∏ List<RedbObject<T>>
            if (propertyType.IsGenericType && propertyType.GetGenericTypeDefinition() == typeof(List<>))
            {
                return propertyType.GetGenericArguments()[0];
            }

            // Fallback
            return typeof(object);
        }

        /// <summary>
        /// –ü–æ–ª—É—á–µ–Ω–∏–µ C# —Ç–∏–ø–∞ –¥–ª—è DbType
        /// </summary>
        private Type GetSimpleTypeForDbType(string? dbType)
        {
            return dbType switch
            {
                "String" => typeof(string),
                "Long" => typeof(long),
                "Boolean" => typeof(bool),
                "DateTime" => typeof(DateTimeOffset),        // ‚≠ê –ò–°–ü–†–ê–í–õ–ï–ù–û (–±—ã–ª DateTime)
                "DateTimeOffset" => typeof(DateTimeOffset),  // ‚≠ê –î–û–ë–ê–í–õ–ï–ù–û
                "Double" => typeof(double),
                "Numeric" => typeof(decimal),                // ‚≠ê –î–û–ë–ê–í–õ–ï–ù–û
                "Guid" => typeof(Guid),
                "ByteArray" => typeof(byte[]),
                "ListItem" => typeof(IRedbListItem),        // ‚≠ê –ò–ó–ú–ï–ù–ï–ù–û: –≤–æ–∑–≤—Ä–∞—â–∞–µ–º IRedbListItem –≤–º–µ—Å—Ç–æ long
                "Object" => typeof(long),                    // ‚≠ê –î–û–ë–ê–í–õ–ï–ù–û (ID)
                _ => typeof(object)
            };
        }
    }
}

